<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>TIP 퀴즈 | NHN Academy</title><link>https://nhnacademy.github.io/quiz/tip/</link><atom:link href="https://nhnacademy.github.io/quiz/tip/index.xml" rel="self" type="application/rss+xml"/><description>TIP 퀴즈</description><generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><copyright>© 2021-2022 NHN Academy Corp. All Rights Reserved.</copyright><lastBuildDate>Thu, 17 Feb 2022 00:00:00 +0000</lastBuildDate><image><url>https://nhnacademy.github.io/media/icon_hu4e12ec6aab5870d438fb169d7a9ab63c_8541_512x512_fill_lanczos_center_3.png</url><title>TIP 퀴즈</title><link>https://nhnacademy.github.io/quiz/tip/</link></image><item><title>1</title><link>https://nhnacademy.github.io/quiz/tip/001/</link><pubDate>Thu, 17 Feb 2022 00:00:00 +0000</pubDate><guid>https://nhnacademy.github.io/quiz/tip/001/</guid><description>&lt;h3 id="몬테카를로-방법">몬테카를로 방법&lt;/h3>
&lt;h4 id="스트림-패러다임">스트림 패러다임&lt;/h4>
&lt;ul>
&lt;li>경남 캠퍼스 1기 웹 서비스 연수 과정 시작 전 방학 숙제로 냈던 문제입니다.&lt;/li>
&lt;li>기술 면접과 코딩 테스트에 나왔던 문제의 답도 엿볼 수 있도록 꾸몄습니다.&lt;/li>
&lt;li>글을 읽고 프로그램이 잘 돌아가도록 코드 속의 &amp;hellip;을 채우세요.&lt;/li>
&lt;/ul>
&lt;ul class="cta-group">
&lt;li>
&lt;a href="https://nhnacademy.github.io/publication/monte_carlo/quiz.pdf" class="btn btn-primary px-3 py-3">Python 판&lt;/a>
&lt;/li>
&lt;/ul></description></item><item><title>2</title><link>https://nhnacademy.github.io/quiz/tip/002/</link><pubDate>Mon, 20 Dec 2021 00:00:00 +0000</pubDate><guid>https://nhnacademy.github.io/quiz/tip/002/</guid><description>&lt;p>$$ g(f(1, f(2, f(3, t)))) = 1, t \in T \tag{1} $$
$$ g(f(1, f(2, f(3, t)))) = 3, t \in T \tag{2} $$
$$ f(f(f(t, i, 1), i, 2), i, 3) = f(t,i,3), $$
$$ g(f(f(f(t, i, 1), j, 2), k, 3), i) = 1, t \in T \tag{3} $$&lt;/p>
&lt;ol>
&lt;li>(1), (2), (3)에서 T는 제 각기 어떤 데이터 타입인가요?&lt;/li>
&lt;li>(1), (2), (3)에서 함수 g와 f는 T의 어떤 연산에 대응하나요?&lt;/li>
&lt;/ol>
&lt;h2 id="도움말">도움말&lt;/h2>
&lt;details class="spoiler " id="spoiler-0">
&lt;summary>귀띔&lt;/summary>
&lt;p>&lt;ul>
&lt;li>데이터에 속하는 값과 연산의 의미를 기술하여 데이터 타입을 정의하는 방식을 두고 &lt;a href="https://en.wikipedia.org/wiki/Abstract_data_type" target="_blank" rel="noopener">Abstract Data Type(ADT)&lt;/a>이라고도 합니다.&lt;/li>
&lt;li>컴퓨터 계산의 복잡도(computational complexity)를 헤아려 자료 구조(data structure)와 알고리즘을 선별하는 공부와 함께, ADT 방식으로 자료 구조(data structure)의 의미를 기술하고 이해하는 연습을 하다 보면, 문제 풀이 방식에 알맞은 연산을 간추릴 수 있고, 이렇게 간추려낸 연산이 필요한 자료 구조를 정의한다는 점도 알게 됩니다.&lt;/li>
&lt;li>소프트웨어 부품의 인터페이스를 설계하는 능력을 기르는데 도움이 되는 공부이기 때문에 (자료 구조를 어떻게 만드는지는 일부러 무시하고) 주요 연산(함수)만 엮어서 테이터 타입을 어떻게 특정할 수 있는지를 맛 보이려고 만든 단편적인 문제입니다.&lt;/li>
&lt;li>데이터 타입의 &lt;a href="https://en.wikipedia.org/wiki/Semantics_%28computer_science%29" target="_blank" rel="noopener">의미(semantics)를 기술하는 데에도 여러 가지 방법&lt;/a> 있습니다.&lt;/li>
&lt;li>ADT 방식에 따라 데이터 타입의 정의를 기술하는 데는 더 많은 공부와 연습이 필요합니다.&lt;/li>
&lt;/ul>
&lt;/p>
&lt;/details>
&lt;details class="spoiler " id="spoiler-1">
&lt;summary>참고 자료&lt;/summary>
&lt;p>&lt;ol>
&lt;li>Barbara Liskov, Stephen Zilles, &lt;em>Programming with abstract data types&lt;/em>, ACM SIGPLAN Notices, Volume 9, Issue 4, April 1974, pp 50~59, &lt;a href="https://doi.org/10.1145/942572.807045" target="_blank" rel="noopener">https://doi.org/10.1145/942572.807045&lt;/a>&lt;/li>
&lt;li>Luca Cardeli, Peter Wegner, &amp;ldquo;&lt;a href="http://lucacardelli.name/papers/onunderstanding.a4.pdf" target="_blank" rel="noopener">On Understanding Types, Data Abstraction, and Polymorphism&lt;/a>&amp;rdquo;, Computing Surveys, Vol 17 n. 4, pp 471-522, December 1985&lt;/li>
&lt;/ol>
&lt;/p>
&lt;/details></description></item><item><title>3</title><link>https://nhnacademy.github.io/quiz/tip/003/</link><pubDate>Tue, 07 Jun 2022 00:00:00 +0000</pubDate><guid>https://nhnacademy.github.io/quiz/tip/003/</guid><description>&lt;pre>&lt;code class="language-python">emptyset =
add =
isin =
union = lambda xs, ys : lambda x : xs( x ) or ys( x )
intersection = lambda xs, ys : lambda x : xs( x ) and ys( x )
complement = lambda xs : lambda x : not xs( x )
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-python">digits = lambda c : '0' &amp;lt;= c and '9' &amp;gt;= c
print( [ isin( c, digits ) for c in 'c90@z3!'] );
alphabets = lambda c : 'A' &amp;lt;= c and 'z' &amp;gt;= c
print( [ isin( c, alphabets ) for c in 'c90@z3!'] );
print( [ isin( c, union(alphabets, digits) ) for c in 'c90@z3!'] );
print( [ isin( c, complement(union(alphabets, digits)) ) for c in 'c90@z3!'] );
print( [ isin( c, complement(intersection(alphabets, digits)) ) for c in 'c90@z3!'] );
&lt;/code>&lt;/pre>
&lt;pre>&lt;code>[False, True, True, False, False, True, False]
[True, False, False, False, True, False, False]
[True, True, True, False, True, True, False]
[False, False, False, True, False, False, True]
[True, True, True, True, True, True, True]
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-python">from functools import reduce
add_all =
{ c if isin( c, add_all(emptyset, &amp;quot;c90@z3!&amp;quot;) ) else '' for c in '123456789' }
&lt;/code>&lt;/pre>
&lt;pre>&lt;code>{'', '3', '9'}
&lt;/code>&lt;/pre>
&lt;ol>
&lt;li>emptyset, add, isin을 정의하세요.&lt;/li>
&lt;li>reduce를 써서 add_all을 정의하세요.&lt;/li>
&lt;/ol>
&lt;h2 id="도움말">도움말&lt;/h2>
&lt;details class="spoiler " id="spoiler-0">
&lt;summary>귀띔&lt;/summary>
&lt;p>&lt;ul>
&lt;li>집합에 원소가 속하는지를 답하는 참-거짓 함수(boolean-valued function, predicate)를 집합의 &lt;a href="https://en.citizendium.org/wiki/Characteristic_function" target="_blank" rel="noopener">characteristic function&lt;/a>이라고 합니다. 이 문제에서는 함수만으로 집합 타입을 나타냅니다.&lt;/li>
&lt;li>함수로 집합을 나타낸다고 하면 언뜻 낯설지만, 사실은 프로그램을 짤 때 (집합 데이터 타입을 표현하는 한 가지 다른 방법이라는 또렷한 인식 없이) 자연스럽게 써오던 방법입니다. 보기를 들어, 짝수 홀수를 판단하는 predicate은 짝수 홀수 집합을 나타냅니다. 조건제시법(set builder form)으로 집합을 표기하는 것과 별다르지 않습니다.&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-python">isodd = lambda x: x % 2 == 1
iseven = lambda x : x % 2 == 0
# 두 predicate의 or는 홀수와 짝수의 합집합 곧 정수 집합을 표현합니다.
isinteger = lambda x: iseven( x ) or isodd( x )
{ i for i in filter( isodd, [ 0.9, 1.4, 2.0, 2, 3, 4.0001 ]) }
&lt;/code>&lt;/pre>
&lt;pre>&lt;code>{3}
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>문제에서는 논리 연산을 쓰지만, 본디 산술 연산을 쓰는 것이 characteristic function으로 표현하는 집합 연산의 정의에 더 가깝습니다. 예를 들어 교집합과 여집합은 아래와 같이 정의합니다. 나머지 연산도 연습 삼아 아래와 같이 만들고 실험해 보세요.&lt;/li>
&lt;/ul>
&lt;pre>&lt;code class="language-python">intersection = lambda xs, ys : lambda x : xs( x ) * ys( x )
complement = lambda xs : lambda x : 1 - xs( x )
&lt;/code>&lt;/pre>
&lt;ul>
&lt;li>데이터 타입을 정의하는 연산을 구현하는 데는 여러 가지 (더러 색다른) 표현 방법이 있습니다. 데이터의 타입(type)과 표현(representation)을 구분 지어 프로그램을 짜는 버릇을 들이면 &lt;a href="https://en.wikipedia.org/wiki/Abstract_data_type#Advantages_of_abstract_data_typing" target="_blank" rel="noopener">프로그램의 틀을 크게 손보지 않고 문제를 푸는데 알맞은 표현법을 바꿔 끼울 수 있도록&lt;/a> 프로그램의 틀을 잡을 수 있습니다. 이 문제는 그렇게 생각하고 연습하는 버릇을 들이는 데 도움이 됩니다.&lt;/li>
&lt;li>한편, &lt;a href="https://ko.wikipedia.org/wiki/%ED%8D%BC%EC%A7%80_%EC%A7%91%ED%95%A9" target="_blank" rel="noopener">Fuzzy Set&lt;/a>은 characteristic function의 치역(range)을 0과 1 사의의 실수(real unit interval [0,1])로 늘려서 원소가 집합에 속하는 정도를 &lt;a href="https://en.wikipedia.org/wiki/Membership_function_%28mathematics%29" target="_blank" rel="noopener">membership 함수&lt;/a>로 나타낸 것이라 할 수 있습니다.&lt;/li>
&lt;/ul>
&lt;/p>
&lt;/details>
&lt;details class="spoiler " id="spoiler-1">
&lt;summary>공부 거리&lt;/summary>
&lt;p>&lt;ol>
&lt;li>집합의 &lt;a href="https://en.wikipedia.org/wiki/Indicator_function" target="_blank" rel="noopener">characteristic function&lt;/a>&lt;/li>
&lt;li>python의 붙박이 &lt;a href="https://docs.python.org/3/library/stdtypes.html#set" target="_blank" rel="noopener">집합&lt;/a>&lt;/li>
&lt;/ol>
&lt;/p>
&lt;/details></description></item></channel></rss>