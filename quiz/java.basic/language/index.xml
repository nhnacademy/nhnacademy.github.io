<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>언어 | NHN Academy</title><link>https://nhnacademy.github.io/quiz/java.basic/language/</link><atom:link href="https://nhnacademy.github.io/quiz/java.basic/language/index.xml" rel="self" type="application/rss+xml"/><description>언어</description><generator>Wowchemy (https://wowchemy.com)</generator><language>en-us</language><copyright>© 2021-2022 NHN Academy Corp. All Rights Reserved.</copyright><lastBuildDate>Fri, 25 Mar 2022 00:00:00 +0000</lastBuildDate><image><url>https://nhnacademy.github.io/media/icon_hu4e12ec6aab5870d438fb169d7a9ab63c_8541_512x512_fill_lanczos_center_3.png</url><title>언어</title><link>https://nhnacademy.github.io/quiz/java.basic/language/</link></image><item><title>Quiz 1</title><link>https://nhnacademy.github.io/quiz/java.basic/language/quiz001/</link><pubDate>Sun, 22 Apr 2007 00:00:00 +0000</pubDate><guid>https://nhnacademy.github.io/quiz/java.basic/language/quiz001/</guid><description>&lt;p>Java에서는 call-by-value로 인자 값을 주고 받습니다.&lt;/p>
&lt;pre>&lt;code class="language-Java">class 물체 {
private int n = 0;
public 물체( int m ) { n = m; }
public void modify( int m ) { n = m; }
public String toString() { return &amp;quot;&amp;quot; + n; }
}
class ParameterPassing {
public static void callByValue( int 복사본 ) { 복사본 = 0; }
public static void callByValue( 물체 copy ) { copy.modify( 0 ); }
public static void test() {
int 원본 = 1;
System.out.println( 원본 );
callByValue( 원본 );
System.out.println( 원본 );
물체 source = new 물체( 1 );
System.out.println( source );
callByValue( source );
System.out.println( source );
}
}
ParameterPassing.test(); // Jupyter notebook에서만
&lt;/code>&lt;/pre>
&lt;pre>&lt;code>1
1
1
0
&lt;/code>&lt;/pre>
&lt;ol>
&lt;li>원본은 바뀌지 않지만, source는 변했습니다. Call-by-value인데도 source가 변한 까닭은 무엇인가요?&lt;/li>
&lt;li>위의 실험 결과로 볼 때 Java는 call-by-reference를 지원한다고 볼 수 있나요?&lt;/li>
&lt;/ol>
&lt;h2 id="도움말">도움말&lt;/h2>
&lt;details class="spoiler " id="spoiler-0">
&lt;summary>Jupyter notebook&lt;/summary>
&lt;p>&lt;a href="https://github.com/SpencerPark/IJava">Java&lt;/a> 커널이 깔린 Jupyter notebook이 아니라면 test()를 곧바로 돌릴 수 없습니다.&lt;/p>
&lt;/details>
&lt;details class="spoiler " id="spoiler-1">
&lt;summary>귀띔&lt;/summary>
&lt;p>Java 언어에서 Value Semantics와 Reference(Pointer) Semantics의 차이를 코드로 시연하면서 설명할 수 있는지 되새겨보는 문제입니다.&lt;/p>
&lt;/details></description></item><item><title>Quiz 2</title><link>https://nhnacademy.github.io/quiz/java.basic/language/quiz002/</link><pubDate>Sun, 22 Apr 2007 00:00:00 +0000</pubDate><guid>https://nhnacademy.github.io/quiz/java.basic/language/quiz002/</guid><description>&lt;p>HashSet으로 1들의 집합을 만듭니다.&lt;/p>
&lt;pre>&lt;code class="language-java">import java.util.*;
class Sameness {
public static void 집합크기(Set 집합, Object[] elements) {
Collections.addAll( 집합, elements ) ;
System.out.println( 집합.toString() + &amp;quot;의 원소 수는 &amp;quot; + 집합.size() );
}
static Integer one = new Integer(1);
static Object ones[] = {
1, 1.0, one, one.intValue(), one.shortValue()
, one.longValue(), one.floatValue(), one.doubleValue()
, new Long(1), new Float(1), new Double(1)
};
}
Sameness.집합크기( new HashSet(), Sameness.ones ); // Jupyter Notebook에서만
&lt;/code>&lt;/pre>
&lt;pre>&lt;code>[1.0, 1.0, 1, 1, 1]의 원소 수는 5
&lt;/code>&lt;/pre>
&lt;ol>
&lt;li>집합의 크기(원소의 개수)가 왜 5일까요?&lt;/li>
&lt;/ol>
&lt;p>분수(유리수)를 정의합니다.&lt;/p>
&lt;pre>&lt;code class="language-java">class 분수 {
public 분수(int numerator, int denominator) throws ArithmeticException {
if ( 0 == denominator ) throw new ArithmeticException( &amp;quot;분모 0&amp;quot; );
분자 = numerator; 분모 = denominator;
if (denominator &amp;lt; 0) { 분자 = - numerator; 분모 = - denominator; }
약분();
}
public int getDenominator() { return 분모; }
public int getNumerator() { return 분자; }
public String toString() { return String.valueOf( 분자 ) + '/' + String.valueOf( 분모 ); }
private void 약분() {
int g = 최대공약수( Math.abs(분자), Math.abs(분모) );
{ 분자 = 분자 / g; 분모 = 분모 / g; }
}
private static int 최대공약수(int x, int y) { return 0 == y ? x : 최대공약수(y, x % y); }
private int 분모, 분자;
}
&lt;/code>&lt;/pre>
&lt;p>이제 분수 집합도 만들 수 있습니다.&lt;/p>
&lt;pre>&lt;code class="language-java">class Two {
static 분수 twos[] = { new 분수( 2, 1 ), new 분수( 4, 2 ), new 분수( -2, -1 ) };
}
Sameness.집합크기( new HashSet(), Two.twos ); // in Jupiter Notebook
&lt;/code>&lt;/pre>
&lt;pre>&lt;code>[2/1, 2/1, 2/1]의 원소 수는 3
&lt;/code>&lt;/pre>
&lt;ol start="2">
&lt;li>집합의 원소 수가 3개입니다. 틀린 답이 나오는 이유를 설명하고 정답이 나오도록 만들어 보세요.&lt;/li>
&lt;li>HashSet 대신에 TreeSet을 써서 같은 실험을 해보세요.&lt;/li>
&lt;/ol>
&lt;h2 id="도움말">도움말&lt;/h2>
&lt;p>&lt;details class="spoiler " id="spoiler-0">
&lt;summary>귀띔&lt;/summary>
&lt;p>두 데이터가 같다는 것은 무슨 뜻일까요? 프로그래밍 언어에서 value equality와 reference (Pointer) equality를 차이를 이해하고, 이어서 새로운 데이터를 만들 때 그 데이터 타입에 속하는 원소(또는 인스턴스) 사이의 같거나 다름을 어떻게 이해하고 정의할 것인지 아니면 아예 정의할 수 없거나 하지 말아야 하는지 따위 주요한 주제를 짚고 넘어가는 문제입니다. &lt;a href="https://en.wikibooks.org/wiki/Java_Programming/Comparing_Objects">Comparing Objects&lt;/a>를 읽어보세요.&lt;/p>
&lt;/details>
&lt;details class="spoiler " id="spoiler-1">
&lt;summary>분수(유리수)&lt;/summary>
&lt;p>&lt;a href="https://commons.apache.org/proper/commons-math/">Apache Commons Math ™ &lt;/a>에 &lt;a href="https://commons.apache.org/proper/commons-math/userguide/fraction.html">Fraction&lt;/a> 클래스가 유리수(분수)를 구현합니다.&lt;/p>
&lt;/details>&lt;/p></description></item><item><title>Quiz 3</title><link>https://nhnacademy.github.io/quiz/java.basic/language/quiz003/</link><pubDate>Sun, 22 Apr 2007 00:00:00 +0000</pubDate><guid>https://nhnacademy.github.io/quiz/java.basic/language/quiz003/</guid><description>&lt;p>&lt;a href="../quiz002">분수&lt;/a>를 수천 개 만들어 쓰는 프로그램을 짜서 돌려 봤더니 분수의 수가 늘어날수록 속도가 떨어집니다. 분수를 만들 때마다 약분을 하기 때문입니다. 분자 분모가 필요할 때만 약분 하도록 getter(또는 Selector)를 고칩니다.&lt;/p>
&lt;pre>&lt;code class="language-java">class 분수 {
public 분수(int numerator, int denominator) throws ArithmeticException {
if ( 0 == denominator ) throw new ArithmeticException( &amp;quot;분모 0&amp;quot; );
분자 = numerator; 분모 = denominator;
if (denominator &amp;lt; 0) { 분자 = - numerator; 분모 = - denominator; }
// 약분();
}
public int getDenominator() { 약분(); return 분모; }
public int getNumerator() { 약분(); return 분자; }
public String toString() { return String.valueOf( 분자 ) + '/' + String.valueOf( 분모 ); }
private void 약분() {
int g = 최대공약수( Math.abs(분자), Math.abs(분모) );
{ 분자 = 분자 / g; 분모 = 분모 / g; }
}
private static int 최대공약수(int x, int y) { return 0 == y ? x : 최대공약수(y, x % y); }
private int 분모, 분자;
}
System.out.println( new 분수(2,4) ) // Jupyter Notebook에서만
&lt;/code>&lt;/pre>
&lt;pre>&lt;code>2/4
&lt;/code>&lt;/pre>
&lt;ol>
&lt;li>기약분수가 찍히지 않습니다. 코드에는 버그가 생겼습니다. 약분을 옮겼을 뿐인데 왜 없던 버그가 갑자기 생겼을까요? 잘못된 부분을 고쳐 써 봅시다.&lt;/li>
&lt;li>분수의 &lt;a href="https://course.ccs.neu.edu/cs5500f14/Notes/Testing1/abstractionBarrierAlt.html" target="_blank" rel="noopener">abstraction barrier&lt;/a>는 어떤 연산으로 이루어지나요? 고쳐 쓴 코드는 abstraction barrier를 무너뜨리지 않나요?&lt;/li>
&lt;li>분수의 분자 분모를 바꾸는 setter가 필요한가요? &lt;code>setNumerator(int)&lt;/code>, &lt;code>setDenominator(int)&lt;/code>는 분수 데이터의 abstraction barrier를 정의하는데 포함되나요?&lt;/li>
&lt;/ol>
&lt;h2 id="도움말">도움말&lt;/h2>
&lt;details class="spoiler " id="spoiler-0">
&lt;summary>귀띔&lt;/summary>
&lt;p>데이터의 What과 How (또는 쓰는 쪽과 만드는 쪽 )을 경계 짓는 &lt;a href="https://course.ccs.neu.edu/cs5500f14/Notes/Testing1/abstractionBarrierAlt.html">abstraction barrier&lt;/a>를 무시하고, 무심코 코드를 쓰면 어떻게 버그가 생겨날 수 있는지를 잘 이해하고 있는지 되새기는 문제입니다.&lt;/p>
&lt;/details>
&lt;details class="spoiler " id="spoiler-1">
&lt;summary>Abstraction Barrier에 대한 공부 거리&lt;/summary>
&lt;p>&lt;ol>
&lt;li>Marvin Zhang, &lt;a href="https://inst.eecs.berkeley.edu/~cs61a/su16/assets/slides/09-Data_Abstraction_1pp.pdf">Lecture 9: Data Abstraction&lt;/a> CS 61A: The Structure and Interpretation of Computer Programs, Berkeley&lt;/li>
&lt;li>Harold Abelson and Gerald Jay Sussman with Julie Sussman, &lt;a href="https://mitpress.mit.edu/sites/default/files/sicp/full-text/sicp/book/node29.html">Abstraction Barriers&lt;/a>, Introduction to Data Abstraction, Building Abstraction with Data, Structure and Interpretation
of Computer Programs&lt;/li>
&lt;/ol>
&lt;/p>
&lt;/details></description></item><item><title>Quiz 4</title><link>https://nhnacademy.github.io/quiz/java.basic/language/quiz004/</link><pubDate>Mon, 18 Jun 2007 00:00:00 +0000</pubDate><guid>https://nhnacademy.github.io/quiz/java.basic/language/quiz004/</guid><description>&lt;pre>&lt;code class="language-mermaid">classDiagram
동물 &amp;lt;|-- 포유류
동물 &amp;lt;|-- 새
포유류 &amp;lt;|-- 박쥐
새 &amp;lt;|-- 펭귄
새 &amp;lt;|-- 참새
&lt;/code>&lt;/pre>
&lt;pre>&lt;code class="language-Java">class Typing {
public static void canFly( 동물 x ) {
System.out.println( x + (x.canFly()? &amp;quot;는(은) 날 수 있어.&amp;quot;: &amp;quot;는(은) 못 날아.&amp;quot;) );
}
}
// Jupyter Notebook에서만
Typing.canFly( new 박쥐() );
Typing.canFly( new 펭귄() );
Typing.canFly( new 참새() );
&lt;/code>&lt;/pre>
&lt;ol>
&lt;li>박쥐, 참새는 날 수 있으나 펭귄은 못 난다고 찍히도록 코드를 쓰세요.&lt;/li>
&lt;li>동물이나 새를 new로 만들 수 있어야 맞나요?&lt;/li>
&lt;li>모든 동물은 나는지 못 나는지 답할 수 있도록 기본 답변을 정의하는 게 맞나요? 아무 답도 않고 미루었다 제각기 다른 답을 하도록 정의하는 게 맞나요? 모든 새는 일단 날 수 있다고 보는 게 맞나요? 새 종류마다 따로 답하도록 미루는 게 맞나요?&lt;/li>
&lt;li>모든 동물에게 헤엄칠 수 있는지 없는지 &lt;code>boolean canSwim()&lt;/code>으로 물을 수 있도록 코드를 고쳐 씁니다. 이런 방식의 장점 단점을 따져 봅시다. 만든 코드에는 손대지 않고 새 코드만 따로 보탤 수 있나요?&lt;/li>
&lt;li>Java 언어에서 (abstract) class 간 extends 관계 곧 implementation inheritance는 코드를 물려 받아 고치고 늘리는 데 어떤 보탬이 되나요?&lt;/li>
&lt;/ol>
&lt;pre>&lt;code class="language-Java">class Typing {
public static void canFly( CanFly x ) {
System.out.println( x + &amp;quot;는(은) 날 수 있어.&amp;quot; );
}
}
// Jupyter Notebook에서만
Typing.canFly( new 박쥐() );
Typing.canFly( new 참새() );
Typing.canFly( new 펭귄() );
&lt;/code>&lt;/pre>
&lt;ol>
&lt;li>박쥐, 참새는 날 수 있지만, 펭귄은 난다 못 난다 답하기도 전에 타입 에러가 나도록 코드를 씁니다.&lt;/li>
&lt;li>헤엄칠 수 있는 동물을 &lt;code>CanSwim&lt;/code> 타입으로 솎아낼 수 있도록 코드를 고치고 늘립니다. 물체를 갖가지 속성에 따라 분류하는 코드를 짤 때 이런 방식의 장점 단점을 따져 봅니다.&lt;/li>
&lt;li>Java 언어에서 interface 사이의 extends, class와 interface 사이의 implements 관계 곧 interface inheritance는 코드를 물려 받아 고치고 늘리는 데 어떤 보탬이 되나요?&lt;/li>
&lt;/ol>
&lt;h2 id="도움말">도움말&lt;/h2>
&lt;details class="spoiler " id="spoiler-0">
&lt;summary>귀띔&lt;/summary>
&lt;p>&lt;ul>
&lt;li>Java 언어의 abstract class, interface가 서로 같고도 다른 점이 무엇인지 또렷이 알고 제대로 쓸 수 있는지를 되새기는 문제입니다.&lt;/li>
&lt;li>Java와 같은 언어에서 implementation inheritance( sub-classing )와 interface inheritance( sub-typing ) 관계란 것을 알고 그에 대응하는 표현 수단을 알며 장점과 단점을 이해하는 지, 그 기본을 되짚어 보는 문제입니다.&lt;/li>
&lt;/ul>
&lt;/p>
&lt;/details></description></item></channel></rss>